'use strict';

/**
* outgoingCalls arriva da additionalProperties (CodegenConfigurator.addAdditionalProperty("outgoingCalls", ...))
*
*/

const outgoingCalls = JSON.parse(
`{{{outgoingCallsJson}}}`
);

// e.g. weight=0.5 >> 50% chance to execute the call
function shouldExecute(weight) {
    if (weight == null) return true;
    const w = Number(weight);
    if (Number.isNaN(w)) return true;
    return Math.random() <= w;
}

// Build the full URL for the outgoing call
function buildUrl(call) {
    // Docker DNS: http://<serviceName>:<internalPort>
    const base = `http://${call.targetService}:${call.port}`;
    const p = call.path && call.path.startsWith('/') ? call.path : `/${call.path || ''}`;
    return base + p;
}

// Build query string for GET parameters
function buildQuery(params) {
    if (!params || !Array.isArray(params) || params.length === 0)
        return '';
    const usp = new URLSearchParams();
    for (const p of params) {
        if (!p || p.name == null) continue;
        usp.append(String(p.name), p.value == null ? '' : String(p.value));
    }
    const q = usp.toString();
    return q ? `?${q}` : '';
}

//
//
// Call an outgoing service based on operationId and body
//
//
async function callOutgoing(operationId) {
    console.log("[OUT] callOutgoing", operationId);
    const call = outgoingCalls.find(c => c.operationId === operationId);
    if (!call) {
        throw new Error(`Outgoing operation ${operationId} not found`);
    }

    if (!shouldExecute(call.weight)) {
        console.warn(`Skipping outgoing call to ${operationId} due to weight ${call.weight}`);
        return;
    }

    let url = buildUrl(call);
    const method = (call.httpMethod || 'GET').toUpperCase();
    const opts = {
        method,
        headers: { 'Content-Type': 'application/json' }
    };

    if (method !== 'GET' && method !== 'HEAD') {
        const params = Array.isArray(call.parameters) ? call.parameters : [];
        opts.body = JSON.stringify(
            Object.fromEntries(params.map(({ name, value }) => [name, value]))
        );
    } else if (call.parameters?.length) {
        call.parameters.length>0? url += buildQuery(call.parameters) : null;
    }

    //
    // Make the outgoing call
    //
    // Node 18+ ha fetch built-in (node:20 ok)
    const res = await fetch(url, opts);
    const text = await res.text();

    // Handle the response
    //
    if (!res.ok) {
        throw new Error(
            `FAIL from service ${call.targetService} during call to ${call.operationId}`
        );
    } else {
        console.log(`Outgoing call to ${url} succeeded: ${res.status} ${res.statusText} - ${text}`);
    }

    // best-effort JSON parse
    try {
        return JSON.parse(text);
    } catch (_) {
        return text;
    }
}

module.exports = { callOutgoing, outgoingCalls };
